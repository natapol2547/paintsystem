From 49175922ec43212e7831711a78200bac971d8312 Mon Sep 17 00:00:00 2001
From: PinkNinjaa <169002704+PinkNinjaa@users.noreply.github.com>
Date: Fri, 2 Jan 2026 21:14:07 +1300
Subject: [PATCH] Added Convert To PS
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Convert to Layers (default):

Original Image → PS Group Input
Original Image → Layer (editable in Paint System)
Result: Image → PS Group → Layer → Image
Duplicate to Layer:

Original Image → PS Group Input (preserved as base)
Duplicated Image → Layer on top (editable copy)
Result: Image → PS Group → Layer → Image.001
This way in DUPLICATE mode, the original image stays connected to the group input providing the base, and the duplicated copy (Image.001) is added as a layer on top that can be painted on without affecting the original image.
---
 operators/common.py          |   2 +-
 operators/group_operators.py | 446 +++++++++++++++++++++++++++++++++++
 panels/extras_panels.py      |  10 +
 panels/main_panels.py        |  11 +
 4 files changed, 468 insertions(+), 1 deletion(-)

diff --git a/operators/common.py b/operators/common.py
index c8a2414..a59f747 100644
--- a/operators/common.py
+++ b/operators/common.py
@@ -94,7 +94,7 @@ class PSUVOptionsMixin:
     use_paint_system_uv: BoolProperty(
         name="Use Paint System UV",
         description="Use the Paint System UV",
-        default=True,
+        default=False,
         update=update_use_paint_system_uv,
         options={'SKIP_SAVE'}
     )
diff --git a/operators/group_operators.py b/operators/group_operators.py
index 616f7a9..85346a5 100644
--- a/operators/group_operators.py
+++ b/operators/group_operators.py
@@ -439,10 +439,456 @@ class PAINTSYSTEM_OT_MoveGroup(PSContextMixin, MultiMaterialOperator):
         return {'FINISHED'}
 
 
+class PAINTSYSTEM_OT_ConvertMaterialToPS(PSContextMixin, PSUVOptionsMixin, MultiMaterialOperator):
+    """Convert an existing material to Paint System by replacing Principled BSDF with paint system groups"""
+    bl_idname = "paint_system.convert_material_to_ps"
+    bl_label = "Convert Material to Paint System"
+    bl_options = {'REGISTER', 'UNDO'}
+    
+    group_name: bpy.props.StringProperty(
+        name="Group Name",
+        description="Name of the new paint system group",
+        default="Paint System",
+    )
+    
+    setup_color: BoolProperty(
+        name="Setup Color Channel",
+        description="Set up Color channel from Base Color input",
+        default=True
+    )
+    
+    setup_metallic: BoolProperty(
+        name="Setup Metallic Channel",
+        description="Set up Metallic channel",
+        default=True
+    )
+    
+    setup_roughness: BoolProperty(
+        name="Setup Roughness Channel",
+        description="Set up Roughness channel",
+        default=True
+    )
+    
+    setup_normal: BoolProperty(
+        name="Setup Normal Channel",
+        description="Set up Normal channel",
+        default=True
+    )
+    
+    setup_emission: BoolProperty(
+        name="Setup Emission Channel",
+        description="Set up Emission channel",
+        default=False
+    )
+    
+    add_layers: BoolProperty(
+        name="Add Layers From Inputs",
+        description="Create layers from existing input connections",
+        default=True
+    )
+    
+    image_mode: EnumProperty(
+        name="Image Mode",
+        description="How to handle images when creating layers",
+        items=[
+            ('CONVERT', "Convert to Layers", "Use existing images directly in layers"),
+            ('DUPLICATE', "Duplicate to Layer", "Create copies of images to preserve originals"),
+        ],
+        default='CONVERT'
+    )
+    
+    @classmethod
+    def poll(cls, context):
+        ps_ctx = cls.parse_context(context)
+        if ps_ctx.ps_object is None or ps_ctx.active_material is None:
+            return False
+        # Check if material has a Principled BSDF
+        mat = ps_ctx.active_material
+        if not mat.use_nodes:
+            return False
+        principled = find_node(mat.node_tree, {'bl_idname': 'ShaderNodeBsdfPrincipled'})
+        return principled is not None
+    
+    def process_material(self, context):
+        ps_ctx = self.parse_context(context)
+        mat = ps_ctx.active_material
+        mat_node_tree = mat.node_tree
+        
+        # Find the Principled BSDF node
+        principled_node = find_node(mat_node_tree, {'bl_idname': 'ShaderNodeBsdfPrincipled'})
+        if principled_node is None:
+            self.report({'ERROR'}, "No Principled BSDF found in material")
+            return {'CANCELLED'}
+        
+        # Create a new paint system group
+        node_tree = bpy.data.node_groups.new(name=f"Temp Group Name", type='ShaderNodeTree')
+        new_group = ps_ctx.ps_mat_data.create_new_group(context, self.group_name, node_tree)
+        new_group.template = 'PBR'
+        
+        # Store coordinate type
+        self.store_coord_type(context)
+        
+        # Get material output for positioning
+        material_output = get_material_output(mat_node_tree)
+        
+        # Store the principled node location for positioning the paint system group
+        ps_group_location = principled_node.location + Vector((-300, 0))
+        
+        # Create paint system group node
+        node_group = mat_node_tree.nodes.new(type='ShaderNodeGroup')
+        node_group.node_tree = node_tree
+        node_group.location = ps_group_location
+        node_group.name = "Paint System Group"
+        
+        # Process each channel
+        channel_setups = []
+        
+        # Color Channel
+        if self.setup_color and 'Base Color' in principled_node.inputs:
+            channel = new_group.create_channel(
+                context, 
+                channel_name='Color', 
+                channel_type='COLOR', 
+                use_alpha=True
+            )
+            channel_setups.append({
+                'channel': channel,
+                'bsdf_input': 'Base Color',
+                'bsdf_alpha_input': 'Alpha',
+                'group_output': 'Color',
+                'group_alpha_output': 'Color Alpha',
+                'needs_layers': True,
+                'layer_type': 'IMAGE'
+            })
+        
+        # Metallic Channel
+        if self.setup_metallic and 'Metallic' in principled_node.inputs:
+            channel = new_group.create_channel(
+                context,
+                channel_name='Metallic',
+                channel_type='FLOAT',
+                use_alpha=False,
+                use_max_min=True,
+                color_space='NONCOLOR'
+            )
+            channel_setups.append({
+                'channel': channel,
+                'bsdf_input': 'Metallic',
+                'group_output': 'Metallic',
+                'needs_layers': True,
+                'layer_type': 'IMAGE'
+            })
+        
+        # Roughness Channel
+        if self.setup_roughness and 'Roughness' in principled_node.inputs:
+            channel = new_group.create_channel(
+                context,
+                channel_name='Roughness',
+                channel_type='FLOAT',
+                use_alpha=False,
+                use_max_min=True,
+                color_space='NONCOLOR'
+            )
+            channel_setups.append({
+                'channel': channel,
+                'bsdf_input': 'Roughness',
+                'group_output': 'Roughness',
+                'needs_layers': True,
+                'layer_type': 'IMAGE'
+            })
+        
+        # Normal Channel
+        if self.setup_normal and 'Normal' in principled_node.inputs:
+            channel = new_group.create_channel(
+                context,
+                channel_name='Normal',
+                channel_type='VECTOR',
+                use_alpha=False,
+                normalize_input=True,
+                color_space='NONCOLOR'
+            )
+            channel_setups.append({
+                'channel': channel,
+                'bsdf_input': 'Normal',
+                'group_output': 'Normal',
+                'needs_layers': True,
+                'layer_type': 'IMAGE',
+                'needs_normal_map': True
+            })
+        
+        # Emission Channel
+        if self.setup_emission and 'Emission Color' in principled_node.inputs:
+            channel = new_group.create_channel(
+                context,
+                channel_name='Emission',
+                channel_type='COLOR',
+                use_alpha=False,
+                color_space='SRGB'
+            )
+            channel_setups.append({
+                'channel': channel,
+                'bsdf_input': 'Emission Color',
+                'group_output': 'Emission',
+                'needs_layers': True,
+                'layer_type': 'IMAGE'
+            })
+        
+        # Transfer connections and create layers
+        for setup in channel_setups:
+            channel = setup['channel']
+            bsdf_input = setup['bsdf_input']
+            group_output = setup['group_output']
+            
+            # Transfer the connection from BSDF input to paint system group input
+            if bsdf_input in principled_node.inputs:
+                input_socket = principled_node.inputs[bsdf_input]
+                group_input_name = group_output  # The group input has the same name as output
+                
+                if group_input_name in node_group.inputs:
+                    has_connection = transfer_connection(
+                        mat_node_tree, 
+                        input_socket, 
+                        node_group.inputs[group_input_name]
+                    )
+                    
+                    # Create layers if add_layers is enabled
+                    if self.add_layers and setup.get('needs_layers', False):
+                        # If there was a connection, try to create a layer from it
+                        if has_connection:
+                            # Check if the connected node is an image texture
+                            if input_socket.is_linked:
+                                from_node = input_socket.links[0].from_node
+                                if from_node.bl_idname == 'ShaderNodeTexImage' and from_node.image:
+                                    original_image = from_node.image
+                                    
+                                    # In DUPLICATE mode: original stays as input, duplicate becomes layer
+                                    # In CONVERT mode: use original as layer (becomes editable)
+                                    if self.image_mode == 'DUPLICATE':
+                                        # Create a duplicate for the layer
+                                        duplicate_image = original_image.copy()
+                                        duplicate_image.name = f"{original_image.name}.001"
+                                        image_to_use = duplicate_image
+                                        layer_name = duplicate_image.name
+                                    else:
+                                        # Convert mode: use original directly
+                                        image_to_use = original_image
+                                        layer_name = original_image.name
+                                    
+                                    # Create an image layer with the image
+                                    layer = channel.create_layer(
+                                        context,
+                                        layer_name=layer_name,
+                                        layer_type='IMAGE',
+                                        coord_type=self.coord_type,
+                                        uv_map_name=self.uv_map_name
+                                    )
+                                    # Set the layer's image
+                                    layer.image = image_to_use
+                                    
+                                    # If extension is CLIP, disable correct_image_aspect
+                                    if hasattr(from_node, 'extension') and from_node.extension == 'CLIP':
+                                        layer.correct_image_aspect = False
+                                else:
+                                    # For other node types, just add a placeholder layer
+                                    channel.create_layer(
+                                        context,
+                                        layer_name='Layer',
+                                        layer_type=setup.get('layer_type', 'IMAGE'),
+                                        coord_type=self.coord_type,
+                                        uv_map_name=self.uv_map_name
+                                    )
+                        else:
+                            # No connection, create a default layer
+                            if bsdf_input == 'Normal':
+                                # For normal, add a geometry layer first
+                                channel.create_layer(
+                                    context,
+                                    layer_name='Object Normal',
+                                    layer_type='GEOMETRY',
+                                    geometry_type='OBJECT_NORMAL',
+                                    normalize_normal=True
+                                )
+                            channel.create_layer(
+                                context,
+                                layer_name='Layer',
+                                layer_type=setup.get('layer_type', 'IMAGE'),
+                                coord_type=self.coord_type,
+                                uv_map_name=self.uv_map_name
+                            )
+                
+                # Handle alpha for color channel
+                if 'bsdf_alpha_input' in setup and setup['bsdf_alpha_input'] in principled_node.inputs:
+                    alpha_input = principled_node.inputs[setup['bsdf_alpha_input']]
+                    if 'group_alpha_output' in setup and setup['group_alpha_output'] in node_group.inputs:
+                        transfer_connection(
+                            mat_node_tree,
+                            alpha_input,
+                            node_group.inputs[setup['group_alpha_output']]
+                        )
+                
+                # Connect paint system group output to BSDF input
+                if group_output in node_group.outputs:
+                    # Handle normal channel specially - needs a normal map node
+                    if setup.get('needs_normal_map', False):
+                        # Check if there's already a normal map node connected
+                        existing_normal_map = None
+                        if input_socket.is_linked:
+                            from_node = input_socket.links[0].from_node
+                            if from_node.bl_idname == 'ShaderNodeNormalMap':
+                                existing_normal_map = from_node
+                        
+                        if existing_normal_map:
+                            # Use the existing normal map node
+                            connect_sockets(node_group.outputs[group_output], existing_normal_map.inputs[1])
+                        else:
+                            # Create a new normal map node
+                            norm_map_node = mat_node_tree.nodes.new(type='ShaderNodeNormalMap')
+                            norm_map_node.location = node_group.location + Vector((300, -300))
+                            norm_map_node.space = 'OBJECT'
+                            connect_sockets(node_group.outputs[group_output], norm_map_node.inputs[1])
+                            connect_sockets(norm_map_node.outputs[0], principled_node.inputs[bsdf_input])
+                    else:
+                        connect_sockets(node_group.outputs[group_output], principled_node.inputs[bsdf_input])
+                    
+                    # Connect alpha for color channel
+                    if 'group_alpha_output' in setup and setup['group_alpha_output'] in node_group.outputs:
+                        alpha_output_name = setup['group_alpha_output']
+                        if 'bsdf_alpha_input' in setup and setup['bsdf_alpha_input'] in principled_node.inputs:
+                            connect_sockets(
+                                node_group.outputs[alpha_output_name],
+                                principled_node.inputs[setup['bsdf_alpha_input']]
+                            )
+        
+        # Keep the principled BSDF and its output connection intact
+        # The paint system group is now providing inputs to it
+        
+        # Set active channel to the first one
+        ps_ctx = self.parse_context(context)
+        if ps_ctx.active_group:
+            ps_ctx.active_group.active_index = 0
+        
+        redraw_panel(context)
+        self.report({'INFO'}, f"Converted material '{mat.name}' to Paint System")
+        return {'FINISHED'}
+    
+    def invoke(self, context, event):
+        ps_ctx = self.parse_context(context)
+        mat = ps_ctx.active_material
+        
+        # Set group name to material name
+        if mat:
+            base_name = mat.name
+            if ps_ctx.ps_mat_data and ps_ctx.ps_mat_data.groups:
+                self.group_name = get_next_unique_name(base_name, [group.name for group in ps_ctx.ps_mat_data.groups])
+            else:
+                self.group_name = base_name
+        
+        # Auto-detect which channels have connections or non-default values
+        mat_node_tree = mat.node_tree
+        principled_node = find_node(mat_node_tree, {'bl_idname': 'ShaderNodeBsdfPrincipled'})
+        
+        if principled_node:
+            # Check Base Color - enable if linked or non-white
+            if 'Base Color' in principled_node.inputs:
+                input_socket = principled_node.inputs['Base Color']
+                is_linked = input_socket.is_linked
+                is_non_default = False
+                if hasattr(input_socket, 'default_value'):
+                    # Check if color is not white (default is usually (0.8, 0.8, 0.8, 1.0))
+                    default_val = input_socket.default_value
+                    is_non_default = not (abs(default_val[0] - 0.8) < 0.01 and 
+                                         abs(default_val[1] - 0.8) < 0.01 and 
+                                         abs(default_val[2] - 0.8) < 0.01)
+                self.setup_color = is_linked or is_non_default
+            
+            # Check Metallic - enable if linked or > 0
+            if 'Metallic' in principled_node.inputs:
+                input_socket = principled_node.inputs['Metallic']
+                is_linked = input_socket.is_linked
+                is_non_default = False
+                if hasattr(input_socket, 'default_value'):
+                    is_non_default = input_socket.default_value > 0.01
+                self.setup_metallic = is_linked or is_non_default
+            
+            # Check Roughness - enable if linked or not 0.5
+            if 'Roughness' in principled_node.inputs:
+                input_socket = principled_node.inputs['Roughness']
+                is_linked = input_socket.is_linked
+                is_non_default = False
+                if hasattr(input_socket, 'default_value'):
+                    # Default roughness is usually 0.5
+                    is_non_default = abs(input_socket.default_value - 0.5) > 0.01
+                self.setup_roughness = is_linked or is_non_default
+            
+            # Check Normal - enable if linked
+            if 'Normal' in principled_node.inputs:
+                self.setup_normal = principled_node.inputs['Normal'].is_linked
+            
+            # Check Emission - enable if linked or emission strength > 0
+            if 'Emission Color' in principled_node.inputs:
+                input_socket = principled_node.inputs['Emission Color']
+                is_linked = input_socket.is_linked
+                has_emission_strength = False
+                if 'Emission Strength' in principled_node.inputs:
+                    strength_socket = principled_node.inputs['Emission Strength']
+                    if hasattr(strength_socket, 'default_value'):
+                        has_emission_strength = strength_socket.default_value > 0.01
+                self.setup_emission = is_linked or has_emission_strength
+            
+            # If nothing is detected, default to standard PBR channels
+            if not any([self.setup_color, self.setup_metallic, self.setup_roughness, self.setup_normal, self.setup_emission]):
+                self.setup_color = True
+                self.setup_roughness = True
+                self.setup_normal = True
+        
+        # Ensure Auto UV is off by default for conversion
+        self.use_paint_system_uv = False
+        self.get_coord_type(context)
+        
+        if ps_ctx.ps_object.mode == 'EDIT':
+            bpy.ops.object.mode_set(mode='OBJECT')
+        
+        return context.window_manager.invoke_props_dialog(self, width=300)
+    
+    def draw(self, context):
+        layout = self.layout
+        self.multiple_objects_ui(layout, context)
+        
+        box = layout.box()
+        row = box.row()
+        row.alignment = "CENTER"
+        row.label(text="Channels to Setup:", icon="MATERIAL")
+        col = box.column(align=True)
+        col.prop(self, "setup_color", text="Color", icon_value=get_icon('color_socket'))
+        col.prop(self, "setup_metallic", text="Metallic", icon_value=get_icon('float_socket'))
+        col.prop(self, "setup_roughness", text="Roughness", icon_value=get_icon('float_socket'))
+        col.prop(self, "setup_normal", text="Normal", icon_value=get_icon('vector_socket'))
+        col.prop(self, "setup_emission", text="Emission", icon_value=get_icon('color_socket'))
+        
+        row = layout.row()
+        scale_content(context, row, 1.5, 1.5)
+        row.prop(self, "add_layers", text="Create Layers From Inputs", icon_value=get_icon('layer_add'))
+        
+        if self.add_layers:
+            box = layout.box()
+            row = box.row()
+            row.label(text="Image Handling:", icon='IMAGE_DATA')
+            col = box.column(align=True)
+            col.prop(self, "image_mode", expand=True)
+            self.select_coord_type_ui(box, context)
+        
+        box = layout.box()
+        row = box.row()
+        row.alignment = "CENTER"
+        row.label(text="Group Settings:", icon="NODETREE")
+        box.prop(self, "group_name", text="Name", icon='NODETREE')
+
+
 classes = (
     PAINTSYSTEM_OT_NewGroup,
     PAINTSYSTEM_OT_DeleteGroup,
     PAINTSYSTEM_OT_MoveGroup,
+    PAINTSYSTEM_OT_ConvertMaterialToPS,
 )
 
 register, unregister = register_classes_factory(classes)    
\ No newline at end of file
diff --git a/panels/extras_panels.py b/panels/extras_panels.py
index 83f7716..231bedc 100644
--- a/panels/extras_panels.py
+++ b/panels/extras_panels.py
@@ -491,6 +491,16 @@ def draw_paint_system_material(self, context):
         row.prop(ps_ctx.active_group, "name", text="")
         row.operator("paint_system.new_group", icon='ADD', text="")
         row.operator("paint_system.delete_group", icon='REMOVE', text="")
+    elif ps_ctx.active_material and ps_ctx.active_material.use_nodes:
+        # Check if material has a Principled BSDF to offer conversion
+        from ..utils.nodes import find_node
+        principled = find_node(ps_ctx.active_material.node_tree, {'bl_idname': 'ShaderNodeBsdfPrincipled'})
+        if principled is not None:
+            box = layout.box()
+            box.label(text="Convert to Paint System:", icon_value=get_icon("sunflower"))
+            row = box.row()
+            scale_content(context, row, 1.3, 1.2)
+            row.operator("paint_system.convert_material_to_ps", text="Convert Material", icon="FILE_REFRESH")
 
 classes = (
     MAT_PT_BrushTooltips,
diff --git a/panels/main_panels.py b/panels/main_panels.py
index 804ca30..9999ea6 100644
--- a/panels/main_panels.py
+++ b/panels/main_panels.py
@@ -286,6 +286,17 @@ class MAT_PT_PaintSystemMainPanel(PSContextMixin, Panel):
             row.scale_x = 2
             row.scale_y = 2
             row.operator("paint_system.new_group", text="Add Paint System", icon="ADD")
+            
+            # Check if material has a Principled BSDF to offer conversion
+            if ps_ctx.active_material and ps_ctx.active_material.use_nodes:
+                from ..utils.nodes import find_node
+                principled = find_node(ps_ctx.active_material.node_tree, {'bl_idname': 'ShaderNodeBsdfPrincipled'})
+                if principled is not None:
+                    box = layout.box()
+                    box.label(text="Convert Existing Material:", icon="MATERIAL")
+                    row = box.row()
+                    row.scale_y = 1.5
+                    row.operator("paint_system.convert_material_to_ps", text="Convert to Paint System", icon="FILE_REFRESH")
             return
         # layout.label(text="Welcome to the Paint System!")
         # layout.operator("paint_system.new_image_layer", text="Create New Image Layer")
-- 
2.52.0

